import streamlit as st  # ì›¹ í™”ë©´ì„ ê·¸ë¦¬ê¸° ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬
import random  # ê²€ìˆ˜ í†µê³¼ ì—¬ë¶€ë¥¼ ë¬´ì‘ìœ„ë¡œ ê²°ì •í•˜ê¸° ìœ„í•´ ë¶ˆëŸ¬ì˜´
from typing import Annotated, TypedDict  # ë°ì´í„° íƒ€ì…ì„ ëª…í™•íˆ ì •ì˜í•˜ê¸° ìœ„í•œ ë„êµ¬
import operator  # ë¦¬ìŠ¤íŠ¸ ë°ì´í„°ë¥¼ í•©ì¹  ë•Œ(add) ì‚¬ìš©í•˜ëŠ” ì—°ì‚°ì
from langgraph.graph import StateGraph, END  # ë­ê·¸ë˜í”„ì˜ í•µì‹¬ êµ¬ì¡°ì¸ ê·¸ë˜í”„ì™€ ì¢…ë£Œ ì§€ì 


# --- [1ë‹¨ê³„] ê³µìš© ê²Œì‹œíŒ(ìƒíƒœ) ì •ì˜ ---
class ChefState(TypedDict):
    """ë¶€ì„œì›ë“¤ì´ ê³µìœ í•˜ëŠ” ì—…ë¬´ ì¼ì§€ì…ë‹ˆë‹¤."""

    # Annotatedì™€ operator.addë¥¼ ì‚¬ìš©í•˜ë©´ ê¸°ì¡´ ë©”ì‹œì§€ì— ìƒˆ ë©”ì‹œì§€ê°€ ê³„ì† ëˆ„ì (Append)ë©ë‹ˆë‹¤.
    messages: Annotated[list[str], operator.add]
    # ìš”ë¦¬ë¥¼ ëª‡ ë²ˆ ë‹¤ì‹œ ì‹œë„í–ˆëŠ”ì§€ ìˆ«ìë¡œ ê¸°ë¡í•˜ì—¬ ë¬´í•œ ë£¨í”„ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤.
    attempts: int


# --- [2ë‹¨ê³„] ê° ë¶€ì„œ(Node) ì—…ë¬´ ì •ì˜ ---


def planning_department(state: ChefState):
    """[ê¸°íšë¶€] ë©”ë‰´ë¥¼ ì •í•˜ê³  ì—…ë¬´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤."""
    st.write("ğŸ” **[ê¸°íšë¶€]** : ì˜¤ëŠ˜ì˜ ë©”ë‰´ëŠ” 'ë§¤ìš´ ë–¡ë³¶ì´'ì…ë‹ˆë‹¤.")
    # ê²Œì‹œíŒì— ê¸°íš ì™„ë£Œë¥¼ ì ê³ , ì‹œë„ íšŸìˆ˜ë¥¼ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ì—¬ ì „ë‹¬í•©ë‹ˆë‹¤.
    return {"messages": ["ê¸°íš: ë§¤ìš´ ë–¡ë³¶ì´ ê¸°íš ì™„ë£Œ"], "attempts": 0}


def cooking_department(state: ChefState):
    """[ì œì‘ë¶€] ê¸°íšì„œë‚˜ ì§€ë°°ì¸ì˜ í”¼ë“œë°±ì„ ë³´ê³  ìš”ë¦¬ë¥¼ ë§Œë“­ë‹ˆë‹¤."""
    # í˜„ì¬ ê²Œì‹œíŒì— ì íŒ ì‹œë„ íšŸìˆ˜ë¥¼ ê°€ì ¸ì™€ì„œ 1ì„ ë”í•©ë‹ˆë‹¤.
    current_attempt = state.get("attempts", 0) + 1
    st.write(f"ğŸ› ï¸ **[ì œì‘ë¶€]** : {current_attempt}ë²ˆì§¸ ë–¡ë³¶ì´ë¥¼ ì—´ì‹¬íˆ ë§Œë“¤ê³  ìˆìŠµë‹ˆë‹¤!")
    # ìš”ë¦¬í•œ ê²°ê³¼ ë©”ì‹œì§€ì™€ ì—…ë°ì´íŠ¸ëœ ì‹œë„ íšŸìˆ˜ë¥¼ ê²Œì‹œíŒì— ì ìŠµë‹ˆë‹¤.
    return {
        "messages": [f"ì œì‘: {current_attempt}ì°¨ ë–¡ë³¶ì´ ì¡°ë¦¬ ì™„ë£Œ"],
        "attempts": current_attempt,
    }


def reviewer_department(state: ChefState):
    """[ê²€ìˆ˜ë¶€] ì™„ì„±ëœ ìš”ë¦¬ë¥¼ ë¨¹ì–´ë³´ê³  í’ˆì§ˆì„ í‰ê°€í•©ë‹ˆë‹¤."""
    st.write("â˜… **[ê²€ìˆ˜ë¶€]** : ì§€ë°°ì¸ì´ ë§›ì„ ë³´ëŠ” ì¤‘ì…ë‹ˆë‹¤...")
    # ê²€ìˆ˜í–ˆë‹¤ëŠ” ì‚¬ì‹¤ë§Œ ê²Œì‹œíŒì— ê¸°ë¡í•©ë‹ˆë‹¤. (í†µê³¼ ì—¬ë¶€ëŠ” ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ê²°ì •)
    return {"messages": ["ê²€ìˆ˜: ì§€ë°°ì¸ì´ ì‹œì‹í•¨"]}


# --- [3ë‹¨ê³„] ê¸¸ì„ ê²°ì •í•˜ëŠ” ì‹ í˜¸ë“± í•¨ìˆ˜ (ê°€ì¥ ì¤‘ìš”!) ---


def should_continue(state: ChefState):
    """ì§€ë°°ì¸ì˜ íŒë‹¨ì— ë”°ë¼ ë‹¤ìŒ ë¶€ì„œë¡œ ë³´ë‚¼ì§€, ì¼ì„ ëë‚¼ì§€ ê²°ì •í•©ë‹ˆë‹¤."""

    # ì—¬ê¸°ì„œëŠ” ì˜ˆì œë¥¼ ìœ„í•´ True(í•©ê²©) / False(ë¶ˆí•©ê²©)ë¥¼ ëœë¤ìœ¼ë¡œ ë½‘ìŠµë‹ˆë‹¤.
    quality_pass = random.choice([False, False])

    # [ë¬´í•œ ë£¨í”„ ë°©ì§€] ìš”ë¦¬ë¥¼ 3ë²ˆì´ë‚˜ ë‹¤ì‹œ í–ˆëŠ”ë°ë„ ì•ˆ ë˜ë©´ ê·¸ëƒ¥ ë‚´ë³´ëƒ…ë‹ˆë‹¤.
    if state["attempts"] >= 3:
        st.warning("âš ï¸ (ì§€ë°°ì¸) : ì‹œê°„ì´ ë„ˆë¬´ ì§€ì²´ëêµ°. ê·¸ëƒ¥ ì´ëŒ€ë¡œ ì†ë‹˜ì—ê²Œ ë“œë ¤!")
        return "finish"  # 'finish'ë¼ëŠ” ì‹ í˜¸ë¥¼ ë³´ëƒ…ë‹ˆë‹¤.

    # í’ˆì§ˆ ê²€ì‚¬ë¥¼ í†µê³¼í–ˆë‹¤ë©´?
    if quality_pass:
        st.success("âœ¨ (ì§€ë°°ì¸) : ë§›ì´ í›Œë¥­í•©ë‹ˆë‹¤! í‡´ê·¼í•˜ì„¸ìš”.")
        return "finish"  # 'finish' ì‹ í˜¸ ë°œìƒ
    # í’ˆì§ˆ ê²€ì‚¬ì— ì‹¤íŒ¨í–ˆë‹¤ë©´?
    else:
        st.error("âŒ (ì§€ë°°ì¸) : ë„ˆë¬´ ì§œìš”! ë‹¤ì‹œ ë§Œë“¤ì–´ ì˜¤ì„¸ìš”!")
        return "retry"  # 'retry' ì‹ í˜¸ë¥¼ ë³´ë‚´ì„œ ë‹¤ì‹œ ìš”ë¦¬í•˜ê²Œ í•©ë‹ˆë‹¤.


# --- [4ë‹¨ê³„] ë¶€ì„œ ë°°ì¹˜ ë° ì§€ëŠ¥í˜• ì§€ë„ êµ¬ì„± ---

# ì§€ë„ë¥¼ ê·¸ë¦´ ë„í™”ì§€(StateGraph)ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.
workflow = StateGraph(ChefState)

# ê° ë¶€ì„œë¥¼ ì§€ë„ ìœ„ì— ì˜¬ë¦½ë‹ˆë‹¤.
workflow.add_node("planner", planning_department)  # ê¸°íš ë¶€ì„œ
workflow.add_node("cook", cooking_department)  # ì¡°ë¦¬ ë¶€ì„œ
workflow.add_node("reviewer", reviewer_department)  # ê²€ìˆ˜ ë¶€ì„œ

# ê¸°ë³¸ í™”ì‚´í‘œë¥¼ ì—°ê²°í•©ë‹ˆë‹¤ (ì§ì§„ ì½”ìŠ¤)
workflow.set_entry_point("planner")  # ì‹œì‘ì€ ê¸°íšë¶€!
workflow.add_edge("planner", "cook")  # ê¸°íš -> ì¡°ë¦¬
workflow.add_edge("cook", "reviewer")  # ì¡°ë¦¬ -> ê²€ìˆ˜

# [í•µì‹¬] ê²€ìˆ˜ë¶€(reviewer) ë‹¤ìŒì—ëŠ” ì¡°ê±´ì— ë”°ë¼ ê¸¸ì´ ê°ˆë¼ì§‘ë‹ˆë‹¤.
workflow.add_conditional_edges(
    "reviewer",  # ì¶œë°œì§€: ê²€ìˆ˜ë¶€
    should_continue,  # íŒë‹¨ í•¨ìˆ˜: ì§€ë°°ì¸ì˜ ì…ë§›
    {
        "retry": "cook",  # í•¨ìˆ˜ê°€ 'retry'ë¥¼ ë°˜í™˜í•˜ë©´ ì¡°ë¦¬ë¶€(cook)ë¡œ ë³µê·€!
        "finish": END,  # í•¨ìˆ˜ê°€ 'finish'ë¥¼ ë°˜í™˜í•˜ë©´ ì—…ë¬´ ì¢…ë£Œ(END)!
    },
)
#cn
# ê·¸ë¦° ì§€ë„ë¥¼ ì‹¤ì œ ì‘ë™í•˜ëŠ” í”„ë¡œê·¸ë¨ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤.
app = workflow.compile()

# --- [5ë‹¨ê³„] ì›¹ í™”ë©´ ì‹¤í–‰ ---

st.title("ğŸ”„ ì¡°ê±´ë¶€ ì´ë™ (Loop & Feedback)")

if st.button("í˜‘ì—… ì£¼ë°© ê°€ë™!"):
    # ê²Œì‹œíŒì´ ë¹„ì–´ìˆëŠ” ìƒíƒœë¡œ ì¼ì„ ì‹œì‘í•©ë‹ˆë‹¤.
    final_result = app.invoke({"messages": [], "attempts": 0})

    st.divider()
    st.subheader("ğŸ“‹ ìµœì¢… ì—…ë¬´ íˆìŠ¤í† ë¦¬")
    # ê²Œì‹œíŒì— ìŒ“ì¸ ëª¨ë“  ë©”ì‹œì§€ë¥¼ í•˜ë‚˜ì”© í™”ë©´ì— ì¶œë ¥í•©ë‹ˆë‹¤.
    for i, msg in enumerate(final_result["messages"]):
        st.write(f"{i+1}. {msg}")
